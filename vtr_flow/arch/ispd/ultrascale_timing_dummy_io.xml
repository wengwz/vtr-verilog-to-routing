<architecture>

<models>
    <model name="multiply">
        <input_ports>
            <port name="a" combinational_sink_ports="out"/>
            <port name="b" combinational_sink_ports="out"/>
        </input_ports>
        <output_ports>
            <port name="out"/>
        </output_ports>
    </model>
    <model name="single_port_ram">
        <input_ports>
            <port name="we" clock="clk"/>
            <!-- control -->
            <port name="addr" clock="clk"/>
            <!-- address lines -->
            <port name="data" clock="clk"/>
            <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
            <port name="clk" is_clock="1"/>
            <!-- memories are often clocked -->
        </input_ports>
        <output_ports>
            <port name="out" clock="clk"/>
            <!-- output can be broken down into smaller bit widths minimum size 1 -->
        </output_ports>
    </model>
    <model name="dual_port_ram">
        <input_ports>
            <port name="we1" clock="clk"/>
            <!-- write enable -->
            <port name="we2" clock="clk"/>
            <!-- write enable -->
            <port name="addr1" clock="clk"/>
            <!-- address lines -->
            <port name="addr2" clock="clk"/>
            <!-- address lines -->
            <port name="data1" clock="clk"/>
            <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
            <port name="data2" clock="clk"/>
            <!-- data lines can be broken down into smaller bit widths minimum size 1 -->
            <port name="clk" is_clock="1"/>
            <!-- memories are often clocked -->
        </input_ports>
        <output_ports>
            <port name="out1" clock="clk"/>
            <!-- output can be broken down into smaller bit widths minimum size 1 -->
            <port name="out2" clock="clk"/>
            <!-- output can be broken down into smaller bit widths minimum size 1 -->
        </output_ports>
    </model>
</models>

<tiles>
    <tile name="io" width="1" height="1" area="0">
        <sub_tile name="io" capacity="1">
            <equivalent_sites>
                <site pb_type="io" pin_mapping="direct"/>
            </equivalent_sites>
            <input name="outpad" num_pins="1"/>
            <output name="inpad" num_pins="1"/>
            <!--TODO: Modify the value of Fc -->
            <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
            <!--TODO: modify the the pattern of pinlocations-->
            
            <pinlocations pattern="custom">
                <loc side="left">io.outpad io.inpad </loc>
                <loc side="top">io.outpad io.inpad </loc>
                <loc side="right">io.outpad io.inpad </loc>
                <loc side="bottom">io.outpad io.inpad </loc>
            </pinlocations>
            <!--TODO: add switchblock_location tag-->
        </sub_tile>
    </tile>

    <tile name="dummy_block" area="0">
        <sub_tile name="dummy_block" capacity="1">
            <equivalent_sites>
                <site pb_type="dummy_block" pin_mapping="direct"/>
            </equivalent_sites>
            <input name="a" num_pins="1"/>
            <input name="b" num_pins="1"/>
            <output name="out" num_pins="1"/>

            <pinlocations pattern="custom">
                <loc side="left"> dummy_block.a dummy_block.b dummy_block.out </loc>
                <loc side="top"> dummy_block.a dummy_block.b dummy_block.out </loc>
                <loc side="right"> dummy_block.a dummy_block.b dummy_block.out </loc>
                <loc side="bottom"> dummy_block.a dummy_block.b dummy_block.out </loc>
            </pinlocations>
            <fc in_type="frac" in_val="0.10" out_type="frac" out_val="0.10"/>
        </sub_tile>
    </tile>

    <tile name="memory" width="1" height="5" area="548000">
        <sub_tile name="memory">
            <equivalent_sites>
                <site pb_type="memory" pin_mapping="direct"/>
            </equivalent_sites>
            <input name="addr1" num_pins="15"/>
            <input name="addr2" num_pins="15"/>
            <input name="data" num_pins="64"/>
            <input name="we1" num_pins="1"/>
            <input name="we2" num_pins="1"/>
            <output name="out" num_pins="64"/>
            <clock name="clk" num_pins="1"/>
            <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
            <pinlocations pattern="spread"/>
        </sub_tile>
    </tile>

    <tile name="mult_36" width="1" height="3" area="396000">
        <sub_tile name="mult_36">
            <equivalent_sites>
                <site pb_type="mult_36" pin_mapping="direct"/>
            </equivalent_sites>
            <input name="a" num_pins="36"/>
            <input name="b" num_pins="36"/>
            <output name="out" num_pins="72"/>
            <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>
            <pinlocations pattern="spread"/>
        </sub_tile>
    </tile>

    <tile name="clb" width="1" height="1" area="53894">
        <sub_tile name="clb">
            <equivalent_sites>
                <site pb_type="clb" pin_mapping="direct"/>
            </equivalent_sites>

            <input name="ALUT_I" num_pins="6"/>
            <input name="BLUT_I" num_pins="6"/>
            <input name="CLUT_I" num_pins="6"/>
            <input name="DLUT_I" num_pins="6"/>
            <input name="ELUT_I" num_pins="6"/>
            <input name="FLUT_I" num_pins="6"/>
            <input name="GLUT_I" num_pins="6"/>
            <input name="HLUT_I" num_pins="6"/>
            <input name="X" num_pins="8"/>
            <input name="I" num_pins="8"/>
            <output name="LUT_O" num_pins="8"/>
            <output name="MUX_O" num_pins="8"/>
            <output name="AQ" num_pins="2"/>
            <output name="BQ" num_pins="2"/>
            <output name="CQ" num_pins="2"/>
            <output name="DQ" num_pins="2"/>
            <output name="EQ" num_pins="2"/>
            <output name="FQ" num_pins="2"/>
            <output name="GQ" num_pins="2"/>
            <output name="HQ" num_pins="2"/>
            <clock name="clk0" num_pins="1"/>
            <clock name="clk1" num_pins="1"/>
            <fc in_type="frac" in_val="0.15" out_type="frac" out_val="0.10"/>

            <pinlocations pattern="spread"/>
        </sub_tile>
    </tile>
</tiles>


<layout>
    <!-- origin layout size: 168x480-->
    <!-- add 2 rows and 2 cols for dummy_block in the perimeter of device layout-->
    <fixed_layout name="vu095" width="170" height="242">
        
        <perimeter type="dummy_block" priority="100"/>
        <corners type="EMPTY" priority="101"/>

        <fill type="clb" priority="1"/>

        <col type="io" startx="1" repeatx="170" priority="10"/>
        <col type="io" startx="67" repeatx="170" priority="10"/>
        <col type="io" startx="68" repeatx="170" priority="10"/>
        <col type="io" startx="104" repeatx="170" priority="10"/>
        <col type="io" startx="105" repeatx="170" priority="10"/>
        <col type="io" startx="168" repeatx="170" priority="10"/>

        <col type="memory" startx="13" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="21" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="27" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="35" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="45" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="53" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="63" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="72" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="82" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="90" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="100" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="109" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="119" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="127" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="137" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="147" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="151" repeatx="170" starty="1" priority="10"/>
        <col type="memory" startx="157" repeatx="170" starty="1" priority="10"/>

        <col type="mult_36" startx="30" repeatx="170" starty="1" priority="10"/>
        <col type="mult_36" startx="66" repeatx="170" starty="1" priority="10"/>
        <col type="mult_36" startx="103" repeatx="170" starty="1" priority="10"/>
        <col type="mult_36" startx="140" repeatx="170" starty="1" priority="10"/>
    </fixed_layout>
</layout>

<device>
    <!-- VB & JL: Using Ian Kuon's transistor sizing and drive strength data for routing, at 40 nm. Ian used BPTM 
			     models. We are modifying the delay values however, to include metal C and R, which allows more architecture
			     experimentation. We are also modifying the relative resistance of PMOS to be 1.8x that of NMOS
			     (vs. Ian's 3x) as 1.8x lines up with Jeff G's data from a 45 nm process (and is more typical of 
			     45 nm in general). I'm upping the Rmin_nmos from Ian's just over 6k to nearly 9k, and dropping 
			     RminW_pmos from 18k to 16k to hit this 1.8x ratio, while keeping the delays of buffers approximately
			     lined up with Stratix IV. 
			     We are using Jeff G.'s capacitance data for 45 nm (in tech/ptm_45nm).
			     Jeff's tables list C in for transistors with widths in multiples of the minimum feature size (45 nm).
			     The minimum contactable transistor is 2.5 * 45 nm, so I need to multiply drive strength sizes in this file
	                     by 2.5x when looking up in Jeff's tables.
			     The delay values are lined up with Stratix IV, which has an architecture similar to this
			     proposed FPGA, and which is also 40 nm 
			     C_ipin_cblock: input capacitance of a track buffer, which VPR assumes is a single-stage
			     4x minimum drive strength buffer. -->
    <sizing R_minW_nmos="8926" R_minW_pmos="16067"/>

    <!-- The grid_logic_tile_area below will be used for all blocks that do not explicitly set their own (non-routing)
     	  area; set to 0 since we explicitly set the area of all blocks currently in this architecture file.
	    -->
    <area grid_logic_tile_area="0"/>

    <chan_width_distr>
        <x distr="uniform" peak="1.000000"/>
        <y distr="uniform" peak="1.000000"/>
    </chan_width_distr>
    <!--TODO: Modify switch block and connection block-->
    <switch_block type="wilton" fs="3"/>
    <connection_block input_switch_name="ipin_cblock"/>
</device>

<switchlist>
    <!-- VB: the mux_trans_size and buf_size data below is in minimum width transistor *areas*, assuming the purple
           book area formula. This means the mux transistors are about 5x minimum drive strength.
           We assume the first stage of the buffer is 3x min drive strength to be reasonable given the large 
           mux transistors, and this gives a reasonable stage ratio of a bit over 5x to the second stage. We assume
           the n and p transistors in the first stage are equal-sized to lower the buffer trip point, since it's fed
           by a pass transistor mux. We can then reverse engineer the buffer second stage to hit the specified 
           buf_size (really buffer area) - 16.2x minimum drive nmos and 1.8*16.2 = 29.2x minimum drive.
           I then took the data from Jeff G.'s PTM modeling of 45 nm to get the Cin (gate of first stage) and Cout 
           (diff of second stage) listed below.  Jeff's models are in tech/ptm_45nm, and are in min feature multiples.
           The minimum contactable transistor is 2.5 * 45 nm, so I need to multiply the drive strength sizes above by 
           2.5x when looking up in Jeff's tables.
           Finally, we choose a switch delay (58 ps) that leads to length 4 wires having a delay equal to that of SIV of 126 ps.
           This also leads to the switch being 46% of the total wire delay, which is reasonable. -->
    <switch type="mux" name="0" R="551" Cin=".77e-15" Cout="4e-15" Tdel="58e-12" mux_trans_size="2.630740" buf_size="27.645901"/>
    <!--switch ipin_cblock resistance set to yeild for 4x minimum drive strength buffer-->
    <switch type="mux" name="ipin_cblock" R="2231.5" Cout="0." Cin="1.47e-15" Tdel="7.247000e-11" mux_trans_size="1.222260" buf_size="auto"/>
</switchlist>

<segmentlist>
    <!--- VB & JL: using ITRS metal stack data, 96 nm half pitch wires, which are intermediate metal width/space.  
             With the 96 nm half pitch, such wires would take 60 um of height, vs. a 90 nm high (approximated as square) Stratix IV tile so this seems
             reasonable. Using a tile length of 90 nm, corresponding to the length of a Stratix IV tile if it were square. -->
    <segment freq="1.000000" length="4" type="unidir" Rmetal="101" Cmetal="22.5e-15">
        <mux name="0"/>
        <sb type="pattern">1 1 1 1 1</sb>
        <cb type="pattern">1 1 1 1</cb>
    </segment>
</segmentlist>

<complexblocklist>
    <!-- Define I/O pads begin -->
    <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
    <!-- Not sure of the area of an I/O (varies widely), and it's not relevant to the design of the FPGA core, so we're setting it to 0. -->

    <pb_type name="io">
        <!-- IOs can operate as either inputs or outputs.
            Delays below come from Ian Kuon. They are small, so they should be interpreted as
            the delays to and from registers in the I/O (and generally I/Os are registered 
            today and that is when you timing analyze them.
        -->
        <input name="outpad" num_pins="1"/>
        <output name="inpad" num_pins="1"/>
        
        <mode name="inpad">
            <pb_type name="inpad" blif_model=".input" num_pb="1">
                <output name="inpad" num_pins="1"/>
            </pb_type>
            <interconnect>
                <direct name="inpad" input="inpad.inpad" output="io.inpad">
                    <delay_constant max="4.243e-11" in_port="inpad.inpad" out_port="io.inpad"/>
                </direct>
            </interconnect>
        </mode>
        <mode name="outpad">
            <pb_type name="outpad" blif_model=".output" num_pb="1">
                <input name="outpad" num_pins="1"/>
            </pb_type>
            <interconnect>
                <direct name="outpad" input="io.outpad" output="outpad.outpad">
                    <delay_constant max="1.394e-11" in_port="io.outpad" out_port="outpad.outpad"/>
                </direct>
            </interconnect>
        </mode>
        <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
        <!-- IOs go on the periphery of the FPGA, for consistency, 
            make it physically equivalent on all sides so that only one definition of I/Os is needed.
            If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
            -->
        <!-- Place I/Os on the sides of the FPGA -->
        <power method="ignore"/>
    </pb_type>

    <!-- Define I/O pads ends -->

    <pb_type name="dummy_block">
        <input name="a" num_pins="1"/>
        <input name="b" num_pins="1"/>
        <output name="out" num_pins="1"/>

        <pb_type name="mult_1x1" blif_model=".subckt multiply" num_pb="1">
            <input name="a" num_pins="1"/>
            <input name="b" num_pins="1"/>
            <output name="out" num_pins="1"/>
            <delay_constant max="1.523e-9" in_port="mult_1x1.a" out_port="mult_1x1.out"/>
            <delay_constant max="1.523e-9" in_port="mult_1x1.b" out_port="mult_1x1.out"/>
        </pb_type>
        <interconnect>
            <direct name="direct_i_1" input="dummy_block.a" output="mult_1x1.a"/>
            <direct name="direct_i_2" input="dummy_block.b" output="mult_1x1.b"/>
            <direct name="direct_i_3" input="mult_1x1.out" output="dummy_block.out"/>
        </interconnect>
    </pb_type>

    <!-- Define general purpose logic block (CLB) begin -->
    <pb_type name="clb">
        <!--TODO: check equivalence of each pin-->
        <input name="ALUT_I" num_pins="6"/>
        <input name="BLUT_I" num_pins="6"/>
        <input name="CLUT_I" num_pins="6"/>
        <input name="DLUT_I" num_pins="6"/>
        <input name="ELUT_I" num_pins="6"/>
        <input name="FLUT_I" num_pins="6"/>
        <input name="GLUT_I" num_pins="6"/>
        <input name="HLUT_I" num_pins="6"/>
        <input name="X" num_pins="8"/>
        <input name="I" num_pins="8"/>

        <output name="LUT_O" num_pins="8"/>
        <output name="MUX_O" num_pins="8"/>
        <output name="AQ" num_pins="2"/>
        <output name="BQ" num_pins="2"/>
        <output name="CQ" num_pins="2"/>
        <output name="DQ" num_pins="2"/>
        <output name="EQ" num_pins="2"/>
        <output name="FQ" num_pins="2"/>
        <output name="GQ" num_pins="2"/>
        <output name="HQ" num_pins="2"/>

        <clock name="clk0" num_pins="1"/>
        <clock name="clk1" num_pins="1"/>
      
        <!-- Describe fracturable logic element.  
             Each fracturable logic element has a 6-LUT that can alternatively operate as two 5-LUTs with shared inputs. 
             The outputs of the fracturable logic element can be optionally registered
        -->
        <pb_type name="fle" num_pb="8">
            <input name="LUT_I" num_pins="6"/>
            <input name="I" num_pins="1"/>
            <input name="X" num_pins="1"/>

            <output name="Q" num_pins="2"/>
            <output name="LUT_O" num_pins="1"/>
            <output name="MUX_O" num_pins="1"/>
            <clock name="clk" num_pins="1"/>
            <!-- n2_lut5 -->
            <mode name="n2_lut5">
                <pb_type name="ble5" num_pb="1">
                    <!--input pins-->
                    <input name="LUT_I" num_pins="5"/>
                    <input name="I" num_pins="1"/>
                    <input name="X" num_pins="1"/>
                    <!--output pins-->
                    <output name="Q" num_pins="2"/>
                    <output name="LUT_O" num_pins="1"/>
                    <output name="MUX_O" num_pins="1"/>
                    <!--clock pin-->
                    <clock name="clk" num_pins="1"/>

                    <pb_type name="lut5" blif_model=".names" num_pb="2" class="lut">
                        <input name="in" num_pins="5" port_class="lut_in"/>
                        <output name="out" num_pins="1" port_class="lut_out"/>
                        <!-- LUT timing using delay matrix -->
                        <!-- These are the physical delay inputs on a Stratix IV LUT but because VPR cannot do LUT rebalancing,
                            we instead take the average of these numbers to get more stable results
                            82e-12
                            173e-12
                            261e-12
                            263e-12
                            398e-12
                            -->
                        <delay_matrix type="max" in_port="lut5.in" out_port="lut5.out">
                            235e-12
                            235e-12
                            235e-12
                            235e-12
                            235e-12
                        </delay_matrix>
                    </pb_type>
                    <pb_type name="ff" blif_model=".latch" num_pb="2" class="flipflop">
                        <input name="D" num_pins="1" port_class="D"/>
                        <output name="Q" num_pins="1" port_class="Q"/>
                        <clock name="clk" num_pins="1" port_class="clock"/>
                        <T_setup value="66e-12" port="ff.D" clock="clk"/>
                        <T_clock_to_Q max="124e-12" port="ff.Q" clock="clk"/>
                    </pb_type>

                    <interconnect>
                        <complete name="complete_clk" input="ble5.clk" output="ff[1:0].clk"/>

                        <direct name="direct_i_1" input="ble5.LUT_I" output="lut5[0:0].in"/>
                        <direct name="direct_i_2" input="ble5.LUT_I" output="lut5[1:1].in"/>
                        <mux name="mux_i_1" input="ble5.I lut5[0:0].out lut5[1:1].out" output="ff[0:0].D">
                            <delay_constant max="25e-12" in_port="lut5[0:0].out" out_port="ff[0:0].D"/>
                            <delay_constant max="25e-12" in_port="lut5[1:1].out" out_port="ff[0:0].D"/>
                            <delay_constant max="25e-12" in_port="ble5.I" out_port="ff[0:0].D"/>
                            <!--TODO: modify pack_pattern-->
                            <pack_pattern name="ble5_0" in_port="lut5[0:0].out" out_port="ff[0:0].D"/>
                            <pack_pattern name="ble5_1" in_port="lut5[1:1].out" out_port="ff[0:0].D"/>
                        </mux>
                        <mux name="mux_i_2" input="ble5.X lut5[0:0].out lut5[1:1].out" output="ff[1:1].D">
                            <delay_constant max="25e-12" in_port="lut5[0:0].out" out_port="ff[1:1].D"/>
                            <delay_constant max="25e-12" in_port="lut5[1:1].out" out_port="ff[1:1].D"/>
                            <delay_constant max="25e-12" in_port="ble5.X" out_port="ff[1:1].D"/>

                            <pack_pattern name="ble5_2" in_port="lut5[0:0].out" out_port="ff[1:1].D"/>
                            <pack_pattern name="ble5_3" in_port="lut5[1:1].out" out_port="ff[1:1].D"/>
                        </mux>

                        <direct name="direct_o_1" input="lut5[0:0].out" output="ble5.LUT_O"/>
                        <mux name="mux_o_1" input="lut5[0:0].out lut5[1:1].out" output="ble5.MUX_O">
                            <delay_constant max="25e-12" in_port="lut5[0:0].out" out_port="ble5.MUX_O"/>
                            <delay_constant max="25e-12" in_port="lut5[1:1].out" out_port="ble5.MUX_O"/>
                        </mux>
                        <direct name="direct_o_2" input="ff[0:0].Q" output="ble5.Q[0]"/>
                        <direct name="direct_o_3" input="ff[1:1].Q" output="ble5.Q[1]"/>
                    </interconnect>
                </pb_type>
                <interconnect>
                    <direct name="direct_clk" input="fle.clk" output="ble5.clk"/>
                    
                    <direct name="direct_i_1" input="fle.LUT_I[4:0]" output="ble5.LUT_I"/>
                    <direct name="direct_i_2" input="fle.X" output="ble5.X"/>
                    <direct name="direct_i_3" input="fle.I" output="ble5.I"/>
                    
                    <direct name="direct_o_1" input="ble5.Q" output="fle.Q"/>
                    <direct name="direct_o_2" input="ble5.LUT_O" output="fle.LUT_O"/>
                    <direct name="direct_o_3" input="ble5.MUX_O" output="fle.MUX_O"/>
                </interconnect>
            </mode>

            <!-- n1_lut6 -->
            <mode name="n1_lut6">
                <pb_type name="ble6" num_pb="1">
                    <!--input pins-->
                    <input name="LUT_I" num_pins="6"/>
                    <input name="I" num_pins="1"/>
                    <input name="X" num_pins="1"/>
                    <!--output pins-->
                    <output name="Q" num_pins="2"/>
                    <output name="LUT_O" num_pins="1"/>
                    <output name="MUX_O" num_pins="1"/>
                    <!--clock pin-->
                    <clock name="clk" num_pins="1"/>

                    <pb_type name="lut6" blif_model=".names" num_pb="1" class="lut">
                        <input name="in" num_pins="6" port_class="lut_in"/>
                        <output name="out" num_pins="1" port_class="lut_out"/>
                        <!-- LUT timing using delay matrix -->
                        <!-- These are the physical delay inputs on a Stratix IV LUT but because VPR cannot do LUT rebalancing,
                                we instead take the average of these numbers to get more stable results
                            82e-12
                            173e-12
                            261e-12
                            263e-12
                            398e-12
                            397e-12
                            -->
                        <delay_matrix type="max" in_port="lut6.in" out_port="lut6.out">
                            261e-12
                            261e-12
                            261e-12
                            261e-12
                            261e-12
                            261e-12
                        </delay_matrix>
                    </pb_type>
                    <pb_type name="ff" blif_model=".latch" num_pb="2" class="flipflop">
                        <input name="D" num_pins="1" port_class="D"/>
                        <output name="Q" num_pins="1" port_class="Q"/>
                        <clock name="clk" num_pins="1" port_class="clock"/>
                        <T_setup value="66e-12" port="ff.D" clock="clk"/>
                        <T_clock_to_Q max="124e-12" port="ff.Q" clock="clk"/>
                    </pb_type>

                    <interconnect>
                        <complete name="complete_clk" input="ble6.clk" output="ff.clk"/>
                        
                        <direct name="direct_i" input="ble6.LUT_I" output="lut6[0:0].in"/>
                        <mux name="mux1" input="ble6.X lut6.out" output="ff[0:0].D">
                            <delay_constant max="25e-12" in_port="ble6.X" out_port="ff[0:0].D"/>
                            <delay_constant max="25e-12" in_port="lut6.out" out_port="ff[0:0].D"/>
                            <pack_pattern name="ble6_0" in_port="lut6.out" out_port="ff[0:0].D"/>
                        </mux>
                        <mux name="mux2" input="ble6.I lut6.out" output="ff[1:1].D">
                            <delay_constant max="25e-12" in_port="ble6.I" out_port="ff[1:1].D"/>
                            <delay_constant max="25e-12" in_port="lut6.out" out_port="ff[1:1].D"/>
                            <pack_pattern name="ble6_1" in_port="lut6.out" out_port="ff[1:1].D"/>
                        </mux>

                        <direct name="direct_o_1" input="lut6.out" output="ble6.LUT_O"/>
                        <direct name="direct_o_2" input="lut6.out" output="ble6.MUX_O">
                            <delay_constant max="25e-12" in_port="lut6.out" out_port="ble6.MUX_O"/>
                        </direct>
                        <direct name="direct_o_3" input="ff[0:0].Q" output="ble6.Q[0]"/>
                        <direct name="direct_o_4" input="ff[1:1].Q" output="ble6.Q[1]"/>
                    </interconnect>
                </pb_type>

                <interconnect>
                    <direct name="direct_clk" input="fle.clk" output="ble6.clk"/>
                    
                    <direct name="direct_i_1" input="fle.LUT_I" output="ble6.LUT_I"/>
                    <direct name="direct_i_2" input="fle.X" output="ble6.X"/>
                    <direct name="direct_i_3" input="fle.I" output="ble6.I"/>
                    
                    <direct name="direct_o_1" input="ble6.Q" output="fle.Q"/>
                    <direct name="direct_o_2" input="ble6.LUT_O" output="fle.LUT_O"/>
                    <direct name="direct_o_3" input="ble6.MUX_O" output="fle.MUX_O"/>
                </interconnect>
            </mode>
        </pb_type>

        <interconnect>
            <!-- We use a 50% depop crossbar built using small full xbars to get sets of logically equivalent pins at inputs of CLB 
            The delays below come from Stratix IV. the delay through a connection block
            input mux + the crossbar in Stratix IV is 167 ps. We already have a 72 ps 
            delay on the connection block input mux (modeled by Ian Kuon), so the remaining
            delay within the crossbar is 95 ps. 
            The delays of cluster feedbacks in Stratix IV is 100 ps, when driven by a LUT.
            Since all our outputs LUT outputs go to a BLE output, and have a delay of 
            25 ps to do so, we subtract 25 ps from the 100 ps delay of a feedback
            to get the part that should be marked on the crossbar.	 -->
            <!-- 50% sparsely populated local routing -->
            <complete name="direct_clk0" input="clb.clk0" output="fle[3:0].clk"/>
            <complete name="direct_clk1" input="clb.clk1" output="fle[7:4].clk"/>

            <direct name="direct_i_0" input="clb.ALUT_I" output="fle[0:0].LUT_I"/>
            <direct name="direct_i_1" input="clb.BLUT_I" output="fle[1:1].LUT_I"/>
            <direct name="direct_i_2" input="clb.CLUT_I" output="fle[2:2].LUT_I"/>
            <direct name="direct_i_3" input="clb.DLUT_I" output="fle[3:3].LUT_I"/>
            <direct name="direct_i_4" input="clb.ELUT_I" output="fle[4:4].LUT_I"/>
            <direct name="direct_i_5" input="clb.FLUT_I" output="fle[5:5].LUT_I"/>
            <direct name="direct_i_6" input="clb.GLUT_I" output="fle[6:6].LUT_I"/>
            <direct name="direct_i_7" input="clb.HLUT_I" output="fle[7:7].LUT_I"/>

            <direct name="direct_i_8" input="clb.X[7:0]" output="fle[7:0].X"/>
            <direct name="direct_i_9" input="clb.I[7:0]" output="fle[7:0].I"/>
            
            <direct name="direct_o_0" input="fle[0:0].Q" output="clb.AQ"/>
            <direct name="direct_o_1" input="fle[1:1].Q" output="clb.BQ"/>
            <direct name="direct_o_2" input="fle[2:2].Q" output="clb.CQ"/>
            <direct name="direct_o_3" input="fle[3:3].Q" output="clb.DQ"/>
            <direct name="direct_o_4" input="fle[4:4].Q" output="clb.EQ"/>
            <direct name="direct_o_5" input="fle[5:5].Q" output="clb.FQ"/>
            <direct name="direct_o_6" input="fle[6:6].Q" output="clb.GQ"/>
            <direct name="direct_o_7" input="fle[7:7].Q" output="clb.HQ"/>

            <direct name="direct_o_8" input="fle[7:0].LUT_O" output="clb.LUT_O[7:0]"/>
            <direct name="direct_o_9" input="fle[7:0].MUX_O" output="clb.MUX_O[7:0]"/>
        </interconnect>
    </pb_type>
    <!-- Define general purpose logic block (CLB) ends -->

    <!-- Define fracturable memory begin -->
    <!-- 32 Kb Memory that can operate from 512x64 to 32Kx1 for single-port mode and 1024x32 to 32Kx1 for dual-port mode.  
           Area and delay based off Stratix IV 9K and 144K memories (delay from linear interpolation, Tsu(483 ps, 636 ps) Tco(1084ps, 1969ps)).  
           Input delay = 204ps (from Stratix IV LAB line) - 72ps (this architecture does not lump connection box delay in internal delay)
           Output delay = M9K buffer 50ps
		   
		   Area is obtained by appropriately scaling and adjusting the published Stratix III (which is architecturally identical to Stratix IV)
		   data from H. Wong, V. Betz and J. Rose, "Comparing FPGA vs. Custom CMOS and the Impact on Processor Microarchitecture", FPGA 2011.
		   Linearly interpolating (by bit count) between the M9k and M144k areas to obtain an M32k (our RAM size) point yields a 65 nm area of
		   of 0.153 mm^2. Interpolating based on port count between the RAMs would instead yield an area of 0.209 mm^2 for our 32 kB RAM; since 
		   bit count accounts for more area than ports for a RAM this size we choose the bit count interpolation; however, since the port interpolation
		   is not radically different this also gives us confidence that interpolating based on bits is OK, but slightly underpredicts area.
		   Scaling to 40 nm^2 yields .0579 mm^2, and converting to MWTUs at 60 L^2 / MWTU yields 604,000 MWTUs. This includes routing. A Stratix IV
		   M9K RAM is one row high and hence has one routing tile (one horizonal and one vertical routing segment area). An M144k RAM has 8 such tiles.
		   Linearly interpolating on
		   bits to 32 kb yields 2.2 routing tiles incorporated in the area number above. The inter-block routing represents 30% of the area of a logic 
		   tile according to D. Lewis et al, "Architectural Enhancements in Stratix V," FPGA 2013. Hence we should subtract 0.3 * 2.2 * 84,375 MWTUs to
		   obtain a RAM core area (not including inter-block routing) of 548,000 MWTU areas for our 32 kb RAM in a 40 nm process.
      -->
    <pb_type name="memory">
        <input name="addr1" num_pins="15"/>
        <input name="addr2" num_pins="15"/>
        <input name="data" num_pins="64"/>
        <input name="we1" num_pins="1"/>
        <input name="we2" num_pins="1"/>
        <output name="out" num_pins="64"/>
        <clock name="clk" num_pins="1"/>
        <!-- Specify single port mode first -->
        <mode name="mem_512x64_sp">
            <pb_type name="mem_512x64_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="9" port_class="address"/>
                <input name="data" num_pins="64" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="64" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_512x64_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_512x64_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_512x64_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_512x64_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[8:0]" output="mem_512x64_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[8:0]" out_port="mem_512x64_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[63:0]" output="mem_512x64_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[63:0]" out_port="mem_512x64_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_512x64_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_512x64_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_512x64_sp.out" output="memory.out[63:0]">
                    <delay_constant max="40e-12" in_port="mem_512x64_sp.out" out_port="memory.out[63:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_512x64_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_1024x32_sp">
            <pb_type name="mem_1024x32_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="10" port_class="address"/>
                <input name="data" num_pins="32" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="32" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_1024x32_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_1024x32_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[9:0]" output="mem_1024x32_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[9:0]" out_port="mem_1024x32_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[31:0]" output="mem_1024x32_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[31:0]" out_port="mem_1024x32_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_1024x32_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_1024x32_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_1024x32_sp.out" output="memory.out[31:0]">
                    <delay_constant max="40e-12" in_port="mem_1024x32_sp.out" out_port="memory.out[31:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_1024x32_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_2048x16_sp">
            <pb_type name="mem_2048x16_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="11" port_class="address"/>
                <input name="data" num_pins="16" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="16" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_2048x16_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_2048x16_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[10:0]" output="mem_2048x16_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[10:0]" out_port="mem_2048x16_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[15:0]" output="mem_2048x16_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[15:0]" out_port="mem_2048x16_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_2048x16_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_2048x16_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_2048x16_sp.out" output="memory.out[15:0]">
                    <delay_constant max="40e-12" in_port="mem_2048x16_sp.out" out_port="memory.out[15:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_2048x16_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_4096x8_sp">
            <pb_type name="mem_4096x8_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="12" port_class="address"/>
                <input name="data" num_pins="8" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="8" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_4096x8_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_4096x8_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_4096x8_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_4096x8_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[11:0]" output="mem_4096x8_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[11:0]" out_port="mem_4096x8_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[7:0]" output="mem_4096x8_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[7:0]" out_port="mem_4096x8_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_4096x8_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_4096x8_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_4096x8_sp.out" output="memory.out[7:0]">
                    <delay_constant max="40e-12" in_port="mem_4096x8_sp.out" out_port="memory.out[7:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_4096x8_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_8192x4_sp">
            <pb_type name="mem_8192x4_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="13" port_class="address"/>
                <input name="data" num_pins="4" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="4" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_8192x4_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_8192x4_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[12:0]" output="mem_8192x4_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[12:0]" out_port="mem_8192x4_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[3:0]" output="mem_8192x4_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[3:0]" out_port="mem_8192x4_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_8192x4_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_8192x4_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_8192x4_sp.out" output="memory.out[3:0]">
                    <delay_constant max="40e-12" in_port="mem_8192x4_sp.out" out_port="memory.out[3:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_8192x4_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_16384x2_sp">
            <pb_type name="mem_16384x2_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="14" port_class="address"/>
                <input name="data" num_pins="2" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="2" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_16384x2_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_16384x2_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[13:0]" output="mem_16384x2_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[13:0]" out_port="mem_16384x2_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[1:0]" output="mem_16384x2_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[1:0]" out_port="mem_16384x2_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_16384x2_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_16384x2_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_16384x2_sp.out" output="memory.out[1:0]">
                    <delay_constant max="40e-12" in_port="mem_16384x2_sp.out" out_port="memory.out[1:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_16384x2_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_32768x1_sp">
            <pb_type name="mem_32768x1_sp" blif_model=".subckt single_port_ram" class="memory" num_pb="1">
                <input name="addr" num_pins="15" port_class="address"/>
                <input name="data" num_pins="1" port_class="data_in"/>
                <input name="we" num_pins="1" port_class="write_en"/>
                <output name="out" num_pins="1" port_class="data_out"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_32768x1_sp.addr" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_sp.data" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_sp.we" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_32768x1_sp.out" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="9.0e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[14:0]" output="mem_32768x1_sp.addr">
                    <delay_constant max="132e-12" in_port="memory.addr1[14:0]" out_port="mem_32768x1_sp.addr"/>
                </direct>
                <direct name="data1" input="memory.data[0:0]" output="mem_32768x1_sp.data">
                    <delay_constant max="132e-12" in_port="memory.data[0:0]" out_port="mem_32768x1_sp.data"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_32768x1_sp.we">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_32768x1_sp.we"/>
                </direct>
                <direct name="dataout1" input="mem_32768x1_sp.out" output="memory.out[0:0]">
                    <delay_constant max="40e-12" in_port="mem_32768x1_sp.out" out_port="memory.out[0:0]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_32768x1_sp.clk">
                </direct>
            </interconnect>
        </mode>
        <!-- Specify true dual port mode next -->
        <mode name="mem_1024x32_dp">
            <pb_type name="mem_1024x32_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
                <input name="addr1" num_pins="10" port_class="address1"/>
                <input name="addr2" num_pins="10" port_class="address2"/>
                <input name="data1" num_pins="32" port_class="data_in1"/>
                <input name="data2" num_pins="32" port_class="data_in2"/>
                <input name="we1" num_pins="1" port_class="write_en1"/>
                <input name="we2" num_pins="1" port_class="write_en2"/>
                <output name="out1" num_pins="32" port_class="data_out1"/>
                <output name="out2" num_pins="32" port_class="data_out2"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_1024x32_dp.addr1" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_dp.data1" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_dp.we1" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_dp.addr2" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_dp.data2" clock="clk"/>
                <T_setup value="509e-12" port="mem_1024x32_dp.we2" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_1024x32_dp.out1" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_1024x32_dp.out2" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="17.9e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[9:0]" output="mem_1024x32_dp.addr1">
                    <delay_constant max="132e-12" in_port="memory.addr1[9:0]" out_port="mem_1024x32_dp.addr1"/>
                </direct>
                <direct name="address2" input="memory.addr2[9:0]" output="mem_1024x32_dp.addr2">
                    <delay_constant max="132e-12" in_port="memory.addr2[9:0]" out_port="mem_1024x32_dp.addr2"/>
                </direct>
                <direct name="data1" input="memory.data[31:0]" output="mem_1024x32_dp.data1">
                    <delay_constant max="132e-12" in_port="memory.data[31:0]" out_port="mem_1024x32_dp.data1"/>
                </direct>
                <direct name="data2" input="memory.data[63:32]" output="mem_1024x32_dp.data2">
                    <delay_constant max="132e-12" in_port="memory.data[63:32]" out_port="mem_1024x32_dp.data2"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_1024x32_dp.we1">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_1024x32_dp.we1"/>
                </direct>
                <direct name="writeen2" input="memory.we2" output="mem_1024x32_dp.we2">
                    <delay_constant max="132e-12" in_port="memory.we2" out_port="mem_1024x32_dp.we2"/>
                </direct>
                <direct name="dataout1" input="mem_1024x32_dp.out1" output="memory.out[31:0]">
                    <delay_constant max="40e-12" in_port="mem_1024x32_dp.out1" out_port="memory.out[31:0]"/>
                </direct>
                <direct name="dataout2" input="mem_1024x32_dp.out2" output="memory.out[63:32]">
                    <delay_constant max="40e-12" in_port="mem_1024x32_dp.out2" out_port="memory.out[63:32]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_1024x32_dp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_2048x16_dp">
            <pb_type name="mem_2048x16_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
                <input name="addr1" num_pins="11" port_class="address1"/>
                <input name="addr2" num_pins="11" port_class="address2"/>
                <input name="data1" num_pins="16" port_class="data_in1"/>
                <input name="data2" num_pins="16" port_class="data_in2"/>
                <input name="we1" num_pins="1" port_class="write_en1"/>
                <input name="we2" num_pins="1" port_class="write_en2"/>
                <output name="out1" num_pins="16" port_class="data_out1"/>
                <output name="out2" num_pins="16" port_class="data_out2"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_2048x16_dp.addr1" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_dp.data1" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_dp.we1" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_dp.addr2" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_dp.data2" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x16_dp.we2" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_2048x16_dp.out1" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_2048x16_dp.out2" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="17.9e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[10:0]" output="mem_2048x16_dp.addr1">
                    <delay_constant max="132e-12" in_port="memory.addr1[10:0]" out_port="mem_2048x16_dp.addr1"/>
                </direct>
                <direct name="address2" input="memory.addr2[10:0]" output="mem_2048x16_dp.addr2">
                    <delay_constant max="132e-12" in_port="memory.addr2[10:0]" out_port="mem_2048x16_dp.addr2"/>
                </direct>
                <direct name="data1" input="memory.data[15:0]" output="mem_2048x16_dp.data1">
                    <delay_constant max="132e-12" in_port="memory.data[15:0]" out_port="mem_2048x16_dp.data1"/>
                </direct>
                <direct name="data2" input="memory.data[31:16]" output="mem_2048x16_dp.data2">
                    <delay_constant max="132e-12" in_port="memory.data[31:16]" out_port="mem_2048x16_dp.data2"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_2048x16_dp.we1">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_2048x16_dp.we1"/>
                </direct>
                <direct name="writeen2" input="memory.we2" output="mem_2048x16_dp.we2">
                    <delay_constant max="132e-12" in_port="memory.we2" out_port="mem_2048x16_dp.we2"/>
                </direct>
                <direct name="dataout1" input="mem_2048x16_dp.out1" output="memory.out[15:0]">
                    <delay_constant max="40e-12" in_port="mem_2048x16_dp.out1" out_port="memory.out[15:0]"/>
                </direct>
                <direct name="dataout2" input="mem_2048x16_dp.out2" output="memory.out[31:16]">
                    <delay_constant max="40e-12" in_port="mem_2048x16_dp.out2" out_port="memory.out[31:16]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_2048x16_dp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_2048x8_dp">
            <pb_type name="mem_2048x8_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
                <input name="addr1" num_pins="12" port_class="address1"/>
                <input name="addr2" num_pins="12" port_class="address2"/>
                <input name="data1" num_pins="8" port_class="data_in1"/>
                <input name="data2" num_pins="8" port_class="data_in2"/>
                <input name="we1" num_pins="1" port_class="write_en1"/>
                <input name="we2" num_pins="1" port_class="write_en2"/>
                <output name="out1" num_pins="8" port_class="data_out1"/>
                <output name="out2" num_pins="8" port_class="data_out2"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_2048x8_dp.addr1" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x8_dp.data1" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x8_dp.we1" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x8_dp.addr2" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x8_dp.data2" clock="clk"/>
                <T_setup value="509e-12" port="mem_2048x8_dp.we2" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_2048x8_dp.out1" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_2048x8_dp.out2" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="17.9e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[11:0]" output="mem_2048x8_dp.addr1">
                    <delay_constant max="132e-12" in_port="memory.addr1[11:0]" out_port="mem_2048x8_dp.addr1"/>
                </direct>
                <direct name="address2" input="memory.addr2[11:0]" output="mem_2048x8_dp.addr2">
                    <delay_constant max="132e-12" in_port="memory.addr2[11:0]" out_port="mem_2048x8_dp.addr2"/>
                </direct>
                <direct name="data1" input="memory.data[7:0]" output="mem_2048x8_dp.data1">
                    <delay_constant max="132e-12" in_port="memory.data[7:0]" out_port="mem_2048x8_dp.data1"/>
                </direct>
                <direct name="data2" input="memory.data[15:8]" output="mem_2048x8_dp.data2">
                    <delay_constant max="132e-12" in_port="memory.data[15:8]" out_port="mem_2048x8_dp.data2"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_2048x8_dp.we1">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_2048x8_dp.we1"/>
                </direct>
                <direct name="writeen2" input="memory.we2" output="mem_2048x8_dp.we2">
                    <delay_constant max="132e-12" in_port="memory.we2" out_port="mem_2048x8_dp.we2"/>
                </direct>
                <direct name="dataout1" input="mem_2048x8_dp.out1" output="memory.out[7:0]">
                    <delay_constant max="40e-12" in_port="mem_2048x8_dp.out1" out_port="memory.out[7:0]"/>
                </direct>
                <direct name="dataout2" input="mem_2048x8_dp.out2" output="memory.out[15:8]">
                    <delay_constant max="40e-12" in_port="mem_2048x8_dp.out2" out_port="memory.out[15:8]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_2048x8_dp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_8192x4_dp">
            <pb_type name="mem_8192x4_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
                <input name="addr1" num_pins="13" port_class="address1"/>
                <input name="addr2" num_pins="13" port_class="address2"/>
                <input name="data1" num_pins="4" port_class="data_in1"/>
                <input name="data2" num_pins="4" port_class="data_in2"/>
                <input name="we1" num_pins="1" port_class="write_en1"/>
                <input name="we2" num_pins="1" port_class="write_en2"/>
                <output name="out1" num_pins="4" port_class="data_out1"/>
                <output name="out2" num_pins="4" port_class="data_out2"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_8192x4_dp.addr1" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_dp.data1" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_dp.we1" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_dp.addr2" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_dp.data2" clock="clk"/>
                <T_setup value="509e-12" port="mem_8192x4_dp.we2" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_8192x4_dp.out1" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_8192x4_dp.out2" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="17.9e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[12:0]" output="mem_8192x4_dp.addr1">
                    <delay_constant max="132e-12" in_port="memory.addr1[12:0]" out_port="mem_8192x4_dp.addr1"/>
                </direct>
                <direct name="address2" input="memory.addr2[12:0]" output="mem_8192x4_dp.addr2">
                    <delay_constant max="132e-12" in_port="memory.addr2[12:0]" out_port="mem_8192x4_dp.addr2"/>
                </direct>
                <direct name="data1" input="memory.data[3:0]" output="mem_8192x4_dp.data1">
                    <delay_constant max="132e-12" in_port="memory.data[3:0]" out_port="mem_8192x4_dp.data1"/>
                </direct>
                <direct name="data2" input="memory.data[7:4]" output="mem_8192x4_dp.data2">
                    <delay_constant max="132e-12" in_port="memory.data[7:4]" out_port="mem_8192x4_dp.data2"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_8192x4_dp.we1">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_8192x4_dp.we1"/>
                </direct>
                <direct name="writeen2" input="memory.we2" output="mem_8192x4_dp.we2">
                    <delay_constant max="132e-12" in_port="memory.we2" out_port="mem_8192x4_dp.we2"/>
                </direct>
                <direct name="dataout1" input="mem_8192x4_dp.out1" output="memory.out[3:0]">
                    <delay_constant max="40e-12" in_port="mem_8192x4_dp.out1" out_port="memory.out[3:0]"/>
                </direct>
                <direct name="dataout2" input="mem_8192x4_dp.out2" output="memory.out[7:4]">
                    <delay_constant max="40e-12" in_port="mem_8192x4_dp.out2" out_port="memory.out[7:4]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_8192x4_dp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_16384x2_dp">
            <pb_type name="mem_16384x2_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
                <input name="addr1" num_pins="14" port_class="address1"/>
                <input name="addr2" num_pins="14" port_class="address2"/>
                <input name="data1" num_pins="2" port_class="data_in1"/>
                <input name="data2" num_pins="2" port_class="data_in2"/>
                <input name="we1" num_pins="1" port_class="write_en1"/>
                <input name="we2" num_pins="1" port_class="write_en2"/>
                <output name="out1" num_pins="2" port_class="data_out1"/>
                <output name="out2" num_pins="2" port_class="data_out2"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_16384x2_dp.addr1" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_dp.data1" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_dp.we1" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_dp.addr2" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_dp.data2" clock="clk"/>
                <T_setup value="509e-12" port="mem_16384x2_dp.we2" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_16384x2_dp.out1" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_16384x2_dp.out2" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="17.9e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[13:0]" output="mem_16384x2_dp.addr1">
                    <delay_constant max="132e-12" in_port="memory.addr1[13:0]" out_port="mem_16384x2_dp.addr1"/>
                </direct>
                <direct name="address2" input="memory.addr2[13:0]" output="mem_16384x2_dp.addr2">
                    <delay_constant max="132e-12" in_port="memory.addr2[13:0]" out_port="mem_16384x2_dp.addr2"/>
                </direct>
                <direct name="data1" input="memory.data[1:0]" output="mem_16384x2_dp.data1">
                    <delay_constant max="132e-12" in_port="memory.data[1:0]" out_port="mem_16384x2_dp.data1"/>
                </direct>
                <direct name="data2" input="memory.data[3:2]" output="mem_16384x2_dp.data2">
                    <delay_constant max="132e-12" in_port="memory.data[3:2]" out_port="mem_16384x2_dp.data2"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_16384x2_dp.we1">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_16384x2_dp.we1"/>
                </direct>
                <direct name="writeen2" input="memory.we2" output="mem_16384x2_dp.we2">
                    <delay_constant max="132e-12" in_port="memory.we2" out_port="mem_16384x2_dp.we2"/>
                </direct>
                <direct name="dataout1" input="mem_16384x2_dp.out1" output="memory.out[1:0]">
                    <delay_constant max="40e-12" in_port="mem_16384x2_dp.out1" out_port="memory.out[1:0]"/>
                </direct>
                <direct name="dataout2" input="mem_16384x2_dp.out2" output="memory.out[3:2]">
                    <delay_constant max="40e-12" in_port="mem_16384x2_dp.out2" out_port="memory.out[3:2]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_16384x2_dp.clk">
                </direct>
            </interconnect>
        </mode>
        <mode name="mem_32768x1_dp">
            <pb_type name="mem_32768x1_dp" blif_model=".subckt dual_port_ram" class="memory" num_pb="1">
                <input name="addr1" num_pins="15" port_class="address1"/>
                <input name="addr2" num_pins="15" port_class="address2"/>
                <input name="data1" num_pins="1" port_class="data_in1"/>
                <input name="data2" num_pins="1" port_class="data_in2"/>
                <input name="we1" num_pins="1" port_class="write_en1"/>
                <input name="we2" num_pins="1" port_class="write_en2"/>
                <output name="out1" num_pins="1" port_class="data_out1"/>
                <output name="out2" num_pins="1" port_class="data_out2"/>
                <clock name="clk" num_pins="1" port_class="clock"/>
                <T_setup value="509e-12" port="mem_32768x1_dp.addr1" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_dp.data1" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_dp.we1" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_dp.addr2" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_dp.data2" clock="clk"/>
                <T_setup value="509e-12" port="mem_32768x1_dp.we2" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_32768x1_dp.out1" clock="clk"/>
                <T_clock_to_Q max="1.234e-9" port="mem_32768x1_dp.out2" clock="clk"/>
                <power method="pin-toggle">
                    <port name="clk" energy_per_toggle="17.9e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <direct name="address1" input="memory.addr1[14:0]" output="mem_32768x1_dp.addr1">
                    <delay_constant max="132e-12" in_port="memory.addr1[14:0]" out_port="mem_32768x1_dp.addr1"/>
                </direct>
                <direct name="address2" input="memory.addr2[14:0]" output="mem_32768x1_dp.addr2">
                    <delay_constant max="132e-12" in_port="memory.addr2[14:0]" out_port="mem_32768x1_dp.addr2"/>
                </direct>
                <direct name="data1" input="memory.data[0:0]" output="mem_32768x1_dp.data1">
                    <delay_constant max="132e-12" in_port="memory.data[0:0]" out_port="mem_32768x1_dp.data1"/>
                </direct>
                <direct name="data2" input="memory.data[1:1]" output="mem_32768x1_dp.data2">
                    <delay_constant max="132e-12" in_port="memory.data[1:1]" out_port="mem_32768x1_dp.data2"/>
                </direct>
                <direct name="writeen1" input="memory.we1" output="mem_32768x1_dp.we1">
                    <delay_constant max="132e-12" in_port="memory.we1" out_port="mem_32768x1_dp.we1"/>
                </direct>
                <direct name="writeen2" input="memory.we2" output="mem_32768x1_dp.we2">
                    <delay_constant max="132e-12" in_port="memory.we2" out_port="mem_32768x1_dp.we2"/>
                </direct>
                <direct name="dataout1" input="mem_32768x1_dp.out1" output="memory.out[0:0]">
                    <delay_constant max="40e-12" in_port="mem_32768x1_dp.out1" out_port="memory.out[0:0]"/>
                </direct>
                <direct name="dataout2" input="mem_32768x1_dp.out2" output="memory.out[1:1]">
                    <delay_constant max="40e-12" in_port="mem_32768x1_dp.out2" out_port="memory.out[1:1]"/>
                </direct>
                <direct name="clk" input="memory.clk" output="mem_32768x1_dp.clk">
                </direct>
            </interconnect>
        </mode>
        <!-- Every input pin is driven by 15% of the tracks in a channel, every output pin is driven by 10% of the tracks in a channel -->
        <!-- Place this memory block every 8 columns from (and including) the second column -->
        <power method="sum-of-children"/>
    </pb_type>
    <!-- Define fracturable memory end -->

    <!-- Define fracturable multiplier begin -->
    <!-- This multiplier can operate as a 36x36 multiplier that can fracture to two 18x18 multipliers each of which can further fracture to two 9x9 multipliers 
	   For delay modelling, the 36x36 DSP multiplier in Stratix IV has a delay of 1.523 ns + 1.93 ns
	    = 3.45 ns. The 18x18 mode doesn't need to sum four 18x18 multipliers, so it is a bit
	   faster: 1.523 ns for the multiplier, and 1.09 ns for the multiplier output block.
	    For the input and output interconnect delays, unlike Stratix IV, we don't
	   have any routing/logic flexibility (crossbars) at the inputs.  There is some output muxing
	   in Stratix IV and this architecture to select which multiplier outputs should go out (e.g.
	   9x9 outputs, 18x18 or 36x36) so those are very close between the two architectures. 
	   We take the conservative (slightly pessimistic)
           approach modelling the input as the same as the Stratix IV input delay and the output delay the same as the Stratix IV DSP out delay.
		   
	   We estimate block area by using the published Stratix III data (which is architecturally identical to Stratix IV)
	      (H. Wong, V. Betz and J. Rose, "Comparing FPGA vs. Custom CMOS and the Impact on Processor Microarchitecture", FPGA 2011) of 0.2623 
		  mm^2 and scaling from 65 to 40 nm to obtain 0.0993 mm^2. That area is for a DSP block with approximately 2x the functionality of 
		  the block we use (can implement two 36x36 multiplies instead of our 1, eight 18x18 multiplies instead of our 4, etc.). Hence we 
		  divide the area by 2 to obtain 0.0497 mm^2. One minimum-width transistor units = 60 L^2 (where L = 40 nm), so is 518,000 MWTUS. 
		  That area includes routing and the connection block input muxes.  Our DSP block is four 
		  rows high, and hence includes four horizontal routing channel segments and four vertical ones, which is 4x the routing of a logic 
		  block (single tile). It also includes 3.6x the outputs of a logic block, and 1.8x the inputs. Hence a slight overestimate of the routing
		  area associated with our DSP block is four times that of a logic tile, where the routing area of a logic tile was calculated above (at W = 300)
		  as 30481 MWTAs. Hence the (core, non-routing) area our DSP block is approximately 518,000 - 4 * 30,481 = 396,000 MWTUs.
      -->
    <pb_type name="mult_36">
        <input name="a" num_pins="36"/>
        <input name="b" num_pins="36"/>
        <output name="out" num_pins="72"/>
        <mode name="two_divisible_mult_18x18">
            <pb_type name="divisible_mult_18x18" num_pb="2">
                <input name="a" num_pins="18"/>
                <input name="b" num_pins="18"/>
                <output name="out" num_pins="36"/>
                <!-- Model 9x9 delay and 18x18 delay as the same.  9x9 could be faster, but in Stratix IV
	              isn't, presumably because the multiplier layout is really optimized for 18x18.
	        	-->
                <mode name="two_mult_9x9">
                    <pb_type name="mult_9x9_slice" num_pb="2">
                        <input name="A_cfg" num_pins="9"/>
                        <input name="B_cfg" num_pins="9"/>
                        <output name="OUT_cfg" num_pins="18"/>
                        <pb_type name="mult_9x9" blif_model=".subckt multiply" num_pb="1">
                            <input name="a" num_pins="9"/>
                            <input name="b" num_pins="9"/>
                            <output name="out" num_pins="18"/>
                            <delay_constant max="1.523e-9" in_port="mult_9x9.a" out_port="mult_9x9.out"/>
                            <delay_constant max="1.523e-9" in_port="mult_9x9.b" out_port="mult_9x9.out"/>
                        </pb_type>
                        <interconnect>
                            <direct name="a2a" input="mult_9x9_slice.A_cfg" output="mult_9x9.a">
                            </direct>
                            <direct name="b2b" input="mult_9x9_slice.B_cfg" output="mult_9x9.b">
                            </direct>
                            <direct name="out2out" input="mult_9x9.out" output="mult_9x9_slice.OUT_cfg">
                            </direct>
                        </interconnect>
                        <power method="pin-toggle">
                            <port name="A_cfg" energy_per_toggle="1.45e-12"/>
                            <port name="B_cfg" energy_per_toggle="1.45e-12"/>
                            <static_power power_per_instance="0.0"/>
                        </power>
                    </pb_type>
                    <interconnect>
                        <direct name="a2a" input="divisible_mult_18x18.a" output="mult_9x9_slice[1:0].A_cfg">
                        </direct>
                        <direct name="b2b" input="divisible_mult_18x18.b" output="mult_9x9_slice[1:0].B_cfg">
                        </direct>
                        <direct name="out2out" input="mult_9x9_slice[1:0].OUT_cfg" output="divisible_mult_18x18.out">
                        </direct>
                    </interconnect>
                </mode>
                <mode name="mult_18x18">
                    <pb_type name="mult_18x18_slice" num_pb="1">
                        <input name="A_cfg" num_pins="18"/>
                        <input name="B_cfg" num_pins="18"/>
                        <output name="OUT_cfg" num_pins="36"/>
                        <pb_type name="mult_18x18" blif_model=".subckt multiply" num_pb="1">
                            <input name="a" num_pins="18"/>
                            <input name="b" num_pins="18"/>
                            <output name="out" num_pins="36"/>
                            <delay_constant max="1.523e-9" in_port="mult_18x18.a" out_port="mult_18x18.out"/>
                            <delay_constant max="1.523e-9" in_port="mult_18x18.b" out_port="mult_18x18.out"/>
                        </pb_type>
                        <interconnect>
                            <direct name="a2a" input="mult_18x18_slice.A_cfg" output="mult_18x18.a">
                            </direct>
                            <direct name="b2b" input="mult_18x18_slice.B_cfg" output="mult_18x18.b">
                            </direct>
                            <direct name="out2out" input="mult_18x18.out" output="mult_18x18_slice.OUT_cfg">
                            </direct>
                        </interconnect>
                        <power method="pin-toggle">
                            <port name="A_cfg" energy_per_toggle="1.09e-12"/>
                            <port name="B_cfg" energy_per_toggle="1.09e-12"/>
                            <static_power power_per_instance="0.0"/>
                        </power>
                    </pb_type>
                    <interconnect>
                        <direct name="a2a" input="divisible_mult_18x18.a" output="mult_18x18_slice.A_cfg">
                        </direct>
                        <direct name="b2b" input="divisible_mult_18x18.b" output="mult_18x18_slice.B_cfg">
                        </direct>
                        <direct name="out2out" input="mult_18x18_slice.OUT_cfg" output="divisible_mult_18x18.out">
                        </direct>
                    </interconnect>
                </mode>
                <power method="sum-of-children"/>
            </pb_type>
            <interconnect>
                <!-- Stratix IV input delay of 207ps is conservative for this architecture because this architecture does not have an input crossbar in the multiplier. 
	            	   Subtract 72.5 ps delay, which is already in the connection block input mux, leading
                    -->
                <direct name="a2a" input="mult_36.a" output="divisible_mult_18x18[1:0].a">
                    <delay_constant max="134e-12" in_port="mult_36.a" out_port="divisible_mult_18x18[1:0].a"/>
                </direct>
                <direct name="b2b" input="mult_36.b" output="divisible_mult_18x18[1:0].b">
                    <delay_constant max="134e-12" in_port="mult_36.b" out_port="divisible_mult_18x18[1:0].b"/>
                </direct>
                <direct name="out2out" input="divisible_mult_18x18[1:0].out" output="mult_36.out">
                    <delay_constant max="1.09e-9" in_port="divisible_mult_18x18[1:0].out" out_port="mult_36.out"/>
                </direct>
            </interconnect>
        </mode>
        <mode name="mult_36x36">
            <pb_type name="mult_36x36_slice" num_pb="1">
                <input name="A_cfg" num_pins="36"/>
                <input name="B_cfg" num_pins="36"/>
                <output name="OUT_cfg" num_pins="72"/>
                <pb_type name="mult_36x36" blif_model=".subckt multiply" num_pb="1">
                    <input name="a" num_pins="36"/>
                    <input name="b" num_pins="36"/>
                    <output name="out" num_pins="72"/>
                    <delay_constant max="1.523e-9" in_port="mult_36x36.a" out_port="mult_36x36.out"/>
                    <delay_constant max="1.523e-9" in_port="mult_36x36.b" out_port="mult_36x36.out"/>
                </pb_type>
                <interconnect>
                    <direct name="a2a" input="mult_36x36_slice.A_cfg" output="mult_36x36.a">
                    </direct>
                    <direct name="b2b" input="mult_36x36_slice.B_cfg" output="mult_36x36.b">
                    </direct>
                    <direct name="out2out" input="mult_36x36.out" output="mult_36x36_slice.OUT_cfg">
                    </direct>
                </interconnect>
                <power method="pin-toggle">
                    <port name="A_cfg" energy_per_toggle="2.13e-12"/>
                    <port name="B_cfg" energy_per_toggle="2.13e-12"/>
                    <static_power power_per_instance="0.0"/>
                </power>
            </pb_type>
            <interconnect>
                <!-- Stratix IV input delay of 207ps is conservative for this architecture because this architecture does not have an input crossbar in the multiplier. 
	            	   Subtract 72.5 ps delay, which is already in the connection block input mux, leading
	            	   to a 134 ps delay.
                    -->
                <direct name="a2a" input="mult_36.a" output="mult_36x36_slice.A_cfg">
                    <delay_constant max="134e-12" in_port="mult_36.a" out_port="mult_36x36_slice.A_cfg"/>
                </direct>
                <direct name="b2b" input="mult_36.b" output="mult_36x36_slice.B_cfg">
                    <delay_constant max="134e-12" in_port="mult_36.b" out_port="mult_36x36_slice.B_cfg"/>
                </direct>
                <direct name="out2out" input="mult_36x36_slice.OUT_cfg" output="mult_36.out">
                    <delay_constant max="1.93e-9" in_port="mult_36x36_slice.OUT_cfg" out_port="mult_36.out"/>
                </direct>
            </interconnect>
        </mode>
        <!-- Place this multiplier block every 8 columns from (and including) the sixth column -->
        <power method="sum-of-children"/>
    </pb_type>
    <!-- Define fracturable multiplier end -->
</complexblocklist>

<power>
    <local_interconnect C_wire="2.5e-10"/>
    <mux_transistor_size mux_transistor_size="3"/>
    <FF_size FF_size="4"/>
    <LUT_transistor_size LUT_transistor_size="4"/>
</power>
<clocks>
    <clock buffer_size="auto" C_wire="2.5e-10"/>
</clocks>


</architecture>
